package main

import (
	"crypto/rand"
	"crypto/rsa"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/pem"
	"fmt"
	"math/big"
	"net"
	"net/http"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	"software.sslmate.com/src/go-pkcs12"
)

func listCertificates(c *gin.Context) {
	files, err := os.ReadDir("./certs")
	if err != nil {
		c.String(http.StatusInternalServerError, "Unable to read certificates directory: %v", err)
		return
	}

	certs := []string{}
	for _, file := range files {
		if file.Type().IsRegular() && strings.HasSuffix(file.Name(), ".pem") {
			name := strings.TrimSuffix(file.Name(), ".pem")
			certs = append(certs, name)
		}
	}

	c.HTML(http.StatusOK, "cert_list.html", gin.H{
		"certificates": certs,
	})
}

func checkRootCertAndListCerts(c *gin.Context) {
	// Check if any .pem file exists in the root-cert directory
	rootCertExists := false
	err := filepath.Walk("root-cert", func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if !info.IsDir() && filepath.Ext(info.Name()) == ".pem" {
			rootCertExists = true
			return filepath.SkipDir
		}
		return nil
	})
	if err != nil {
		c.String(http.StatusInternalServerError, "Error checking root-cert directory: %v", err)
		return
	}

	if rootCertExists {
		listCertificates(c)
	} else {
		c.Redirect(http.StatusSeeOther, "/")
	}
}

func createCertificate(c *gin.Context) {
	commonName := c.PostForm("common_name")
	dnsNames := c.PostFormArray("dns_names[]")
	ipAddresses := c.PostFormArray("ip_addresses[]")
	validityYearsStr := c.PostForm("validity_years")

	validityYears, err := strconv.Atoi(validityYearsStr)
	if err != nil {
		c.String(http.StatusBadRequest, "Invalid validity period: %v", err)
		return
	}

	privateKey, err := rsa.GenerateKey(rand.Reader, 2048)
	if err != nil {
		c.String(http.StatusInternalServerError, "Error generating private key: %v", err)
		return
	}

	certTemplate := &x509.Certificate{
		SerialNumber: big.NewInt(1),
		Subject: pkix.Name{
			CommonName: commonName,
		},
		NotBefore:             time.Now(),
		NotAfter:              time.Now().AddDate(validityYears, 0, 0),
		KeyUsage:              x509.KeyUsageDigitalSignature,
		ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
		BasicConstraintsValid: true,
	}

	// Adding DNS Names directly without the loop
	certTemplate.DNSNames = append(certTemplate.DNSNames, dnsNames...)

	// Adding IP Addresses
	for _, ip := range ipAddresses {
		parsedIP := net.ParseIP(ip)
		if parsedIP != nil {
			certTemplate.IPAddresses = append(certTemplate.IPAddresses, parsedIP)
		}
	}

	// Load root certificate and key
	rootCert, rootKey, err := loadRootCertAndKey()
	if err != nil {
		c.String(http.StatusInternalServerError, "Error loading root certificate and key: %v", err)
		return
	}

	certBytes, err := x509.CreateCertificate(rand.Reader, certTemplate, rootCert, &privateKey.PublicKey, rootKey)
	if err != nil {
		c.String(http.StatusInternalServerError, "Error creating certificate: %v", err)
		return
	}

	sanitizedCommonName := strings.ReplaceAll(commonName, " ", "_")
	certFilename := "certs/" + sanitizedCommonName + ".pem"
	keyFilename := "certs/" + sanitizedCommonName + ".key"
	pfxFilename := "certs/" + sanitizedCommonName + ".pfx"

	certFile, err := os.Create(certFilename)
	if err != nil {
		c.String(http.StatusInternalServerError, "Error creating certificate file: %v", err)
		return
	}
	defer certFile.Close()
	pem.Encode(certFile, &pem.Block{Type: "CERTIFICATE", Bytes: certBytes})

	keyFile, err := os.Create(keyFilename)
	if err != nil {
		c.String(http.StatusInternalServerError, "Error creating key file: %v", err)
		return
	}
	defer keyFile.Close()
	pem.Encode(keyFile, &pem.Block{Type: "RSA PRIVATE KEY", Bytes: x509.MarshalPKCS1PrivateKey(privateKey)})

	// Generate .pfx file for certificate
	cert, err := x509.ParseCertificate(certBytes)
	if err != nil {
		c.String(http.StatusInternalServerError, "Error parsing certificate: %v", err)
		return
	}

	pfxData, err := pkcs12.Encode(rand.Reader, privateKey, cert, []*x509.Certificate{rootCert}, "")
	if err != nil {
		c.String(http.StatusInternalServerError, "Error creating .pfx file: %v", err)
		return
	}

	pfxFile, err := os.Create(pfxFilename)
	if err != nil {
		c.String(http.StatusInternalServerError, "Error creating .pfx file: %v", err)
		return
	}
	defer pfxFile.Close()

	pfxFile.Write(pfxData)

	c.Redirect(http.StatusSeeOther, "/certificates")
}

func loadRootCertAndKey() (*x509.Certificate, *rsa.PrivateKey, error) {
	// Locate the root certificate file
	var rootCert *x509.Certificate
	var rootKey *rsa.PrivateKey
	err := filepath.Walk("root-cert", func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if !info.IsDir() && filepath.Ext(info.Name()) == ".pem" {
			rootCertBytes, err := os.ReadFile(path)
			if err != nil {
				return err
			}
			block, _ := pem.Decode(rootCertBytes)
			if block == nil {
				return fmt.Errorf("failed to parse root certificate PEM")
			}
			rootCert, err = x509.ParseCertificate(block.Bytes)
			if err != nil {
				return err
			}
		}
		return nil
	})

	if err != nil {
		return nil, nil, err
	}

	err = filepath.Walk("root-cert", func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if !info.IsDir() && filepath.Ext(info.Name()) == ".key" {
			rootKeyBytes, err := os.ReadFile(path)
			if err != nil {
				return err
			}
			block, _ := pem.Decode(rootKeyBytes)
			if block == nil {
				return fmt.Errorf("failed to parse root key PEM")
			}
			key, err := x509.ParsePKCS1PrivateKey(block.Bytes)
			if err != nil {
				return err
			}
			rootKey = key
		}
		return nil
	})

	return rootCert, rootKey, err
}

func downloadCertificate(c *gin.Context) {
	fileName := c.Param("filename")
	filePath := "./certs/" + fileName

	c.Header("Content-Description", "File Transfer")
	c.Header("Content-Transfer-Encoding", "binary")
	c.Header("Content-Disposition", fmt.Sprintf("attachment; filename=%s", fileName))
	switch {
	case strings.HasSuffix(fileName, ".pem"):
		c.Header("Content-Type", "application/x-pem-file")
	case strings.HasSuffix(fileName, ".key"):
		c.Header("Content-Type", "application/x-iwork-keynote-sffkey")
	case strings.HasSuffix(fileName, ".pfx"):
		c.Header("Content-Type", "application/x-pkcs12")
	default:
		c.Header("Content-Type", "application/octet-stream")
	}
	c.File(filePath)
}

func deleteCertificate(c *gin.Context) {
	fileName := c.Param("filename")
	filePath := "./certs/" + fileName

	err := os.Remove(filePath)
	if err != nil {
		c.String(http.StatusInternalServerError, "Error deleting certificate: %v", err)
		return
	}

	// Redirect to the certificates list page after deletion
	c.Redirect(http.StatusSeeOther, "/certificates")
}

func viewCertificate(c *gin.Context) {
	fileName := c.Param("filename")
	filePath := "./certs/" + fileName

	// Check if the file exists
	if _, err := os.Stat(filePath); os.IsNotExist(err) {
		c.String(http.StatusNotFound, "File not found")
		return
	}

	// Read the file content
	content, err := os.ReadFile(filePath)
	if err != nil {
		c.String(http.StatusInternalServerError, "Error reading certificate: %v", err)
		return
	}

	// Decode the certificate
	block, _ := pem.Decode(content)
	if block == nil {
		c.String(http.StatusInternalServerError, "Failed to parse certificate PEM")
		return
	}

	cert, err := x509.ParseCertificate(block.Bytes)
	if err != nil {
		c.String(http.StatusInternalServerError, "Failed to parse certificate: %v", err)
		return
	}

	// Create a decoded view of the certificate
	decoded := fmt.Sprintf("Issuer: %s\nSubject: %s\nValidity:\n  Not Before: %s\n  Not After : %s\n", cert.Issuer, cert.Subject, cert.NotBefore, cert.NotAfter)

	// Return the file content and decoded view as JSON
	c.JSON(http.StatusOK, gin.H{
		"encoded": string(content),
		"decoded": decoded,
	})
}
